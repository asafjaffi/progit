# מתחילים #

הפרק הזה יעסוק באיך מתחילים עם Git. נתחיל בהתחלה, וניתן מעט רקע על כלים לניהול גרסאות, ומשם נמשיך לכיצד להריץ את Git על המערכת שלך, ולבסוף, כיצד להתקין אותו כדי להתחיל לעבוד. בסוף פרק זה תביני מדוע Git קיים, למה לך להשתמש בו ותהיי מוכנה לעשות זאת.

## ניהול גרסאות ##

מהו ניהול גרסאות, ומדוע שיהיה לך אכפת? ניהול גרסאות הוא מערכת שרושמת שינויים בקובץ או בקבוצת קבצים לאורך זמן כך שמאוחר יותר תוכלי לשחזר גרסאות מסויימות. בדוגמאות בספר זה תשתמשי בקוד תוכנה בקבצים שעבורם ננהל גרסאות, למרות שבמציאות תוכלי לעשות זאת עם כמעט כל סוג קובץ במחשב.

אם את מעצבת גרפיקה או אתרים ותרצי לשמור כל גרסא של כל תמונה או עימוד (layout, שאותו בטוח תרצי לשמור), שימוש במערכת לניהול גרסאות (VCS) יהיה צעד נבון. הוא מאפשר לך להחזיר קבצים למצבם הקודם, להחזיר פרוייקט שלם למצבו הקודם, להשוות שינויים לאורך זמן, לראות מי האחרון  ששינה משהו שאולי גורם לבעיה, מי הכניס נושא מסויים ומתי, ועוד. ניהול גרסאות בדרך כלל אומר גם שאם דפקת משהו או איבדת קבצים, את יכולה להתאושש מהר. בנוסף, את מקבלת את כל זה כשאת משלמת מעט מאוד על כל פעולה.

### ניהול גרסאות מקומי ###

כדי לנהל גרסאות, הרבה אנשים נוקטים בשיטה של העתקת קבצים לספריה אחרת (אם הם נבונים, הם אולי אפילו מתעדים את זמן השמירה). הגישה הזו כה נפוצה מכיוון שהיא כה פשוטה, אבל היא גם מועדת מאוד לטעויות. קל מאוד לשכוח באיזו ספרייה את ולכתוב לתוך קבצים לא נכונים או להעתיק ולדרוס קבצים בלי כוונה.

כדי להתמודד עם הבעיה הזו, מתכנתים פיתחו ממזמן מנהלי גרסאות מקומיים עם בסיסי מידע פשוטים ששמרו את כל השינויים שנעשו בקבצים שעבורם נוהלו השיכתובים (ראי תרשים 1-1).

Insert 18333fig0101.png 
תרשים 1-1. תרשים של ניהול גרסאות מקומי.

אחד מהכלים היותר פופולריים לנהול גרסאות היה מערכת ששמה rcs, שעדיין מופצת היום עם הרבה מחשבים. אפילו מערכת ההפעלה  Mac OS X הפופולרית כוללת את פקודת ה rcs כשאת מתקינה את כלי הפיתוח (Developer Tools). באופן בסיסי, הכלי הזה עובד על ידי שמירת קבוצות של טלאים (כלומר, ההבדלים בין קבצים) משינוי אחד לשני, בפורמט מיוחד על הדיסק; כך הוא יכול לשחזר איך כל קובץ נראה בכל נקודת זמן על ידי סיכום כל הטלאים.

### ניהול גרסאות ריכוזי ###

הצורך לשתף פעולה עם מפתחים שעבדו על מערכות אחרות היווה את הבעיה המשמעותית הבאה. כדי להתמודד איתה, פותחו מנהלי גרסאות ריכוזיים (CVCSs). למערכות אלו, כדוגמת CVS, Subversion או Perforce, יש שרת יחיד שמכיל את כל הקבצים המנוהלים, ומספר לקוחות שמוציאים קבצים מאותו מקום מרכזי. במשך שנים ארוכות זה היה ניהול הגרסאות הסטנדרטי (ראי תרשים 1-2).

Insert 18333fig0102.png 
תרשים 1-2. תרשים של ניהול גרסאות ריכוזי.

המבנה הזה הציע יתרונות רבים, במיוחד לעומת גרסאות מקומיות. לדוגמא, כולם יודעים במידה מסויימת מה כל אחד בפרוייקט עושה. למנהלים יש שליטה מדוייקת על מי יכול לעשות מה; וזה קל הרבה יותר לנהל מערכת ריכוזית מאשר להתעסק עם בסיסי מידע מקומיים בכל תחנת קצה.

עם זאת, למבנה הזה יש כמה חסרונות רציניים. הבולט מביניהם הוא שהשרת מהווה למעשה נקודת כשל יחידה. אם השרת מושבת למשך שעה, אז במשך שעה זו אף אחד לא יכול לשתף בכלל, או לשמור גרסאות עם שינויים על שום דבר שעובדים עליו. אם הדיסק הקשיח, שבסיס הנתונים עליו, נפגם ולא נשמרו גיבויים סדירים, את פשוט מאבדת את הכל - את כל ההיסטוריה של הפרוייקט, למעט תמונות מצב (snapshots) שיש במקרה לאנשים על המכונות המקומיות שלהם. גרסאות מקומיות סובלות מאותה הבעיה בדיוק - כל זמן שיש לך את כל ההיסטוריה של הפרוייקט במקום אחד, את מסתכנת בכך שתאבדי את כולו.

### ניהול גרסאות מבוזר ###

כאן נכנסות לתמונה מערכות ניהול גרסאות מבוזרות (DVCSs). בניהול גרסאות מבוזר (כגון Git, Mercurial, Bazaar או Darcs), לקוחות לא סתם מוציאים את העותקים האחרונים של הקבצים: הם משקפים את המאגר (repository) במלואו. וכך, אם איזשהו שרת מת, והמערכות האלו שיתפו דרכו, אפשר להעתיק כל אחד ממאגרי הלקוח חזרה לשרת ולשחזר אותו. למעשה, כל גרסא שיוצאת מהשרת היא גיבוי מלא של כל המידע (ראי תרשים 1-3).

Insert 18333fig0103.png 
תרשים 1-3. תרשים של ניהול גרסאות מבוזר.

יתרה מכך, רבים מהכלים האלו מתמודדים די טוב עם עבודה מול מספר מאגרים מרוחקים, כך שאת יכולה לשתף פעולה עם קבוצות אנשים שונות בדרכים שונות באותו פרוייקט בעת ובעונה אחת. כך ניתן לקבוע סוגים של  תהליכי עבודה שאינם אפשריים במערכות ריכוזיות, כגון מודלים היררכיים.

## היסטוריה קצרה של Git ##

כמו הרבה דברים טובים בחיים, Git התחיל עם מעט הרסנות יצירתית וחילוקי דעות לוהטים. הליבה של לינוקס (The Linux kernel) הוא פרוייקט תוכנה בקוד פתוח בקנה מידה די גדול. במשך רוב חיי התחזוקה של הפרוייקט (1991-2002), שינויים בתוכנה נמסרו כטלאים וכקבצי ארכיון. בשנת 2002, הפרוייקט החל להשתמש במערכת גרסאות מבוזרת פרטית (קניינית) שנקראה BitKeeper.

בשנת 2005, הסתיימו היחסים בין הקהילה שפיתחה את הליבה ובין החברה המסחרית שפיתחה את BitKeeper, ובוטלה האפשרות להשתמש בכלי ללא תשלום. מצב זה הביא את קהילת מפתחי לינוקס (ובמיוחד את לינוס טרובלדס, היוצר של לינוקס) לפתח כלי משלהם בהתבסס על כמה מהלקחים שלמדו תוך כדי השימוש ב BitKeeper. מספר מטרות המערכת החדשה היו כדלקמן:

*	מהירות
*	תכנון פשוט
*	תמיכה איתנה בפיתוח לא-לינארי (אלפי ענפים במקביל)
*	מבוזר לחלוטין
*	יכולת להתמודד ביעילות עם פרוייקטים גדולים כדוגמת הליבה של לינוקס (מהירות וכמות המידע)

מאז לידתו ב 2005, Git התפתח והבשיל לכלי קל לשימוש שעדיין שומר על האיכויות הראשוניות האלו. הוא מהיר באופן בלתי יאומן, יעיל ביותר בפרוייקטים רחבי היקף, ובעל מערכת הסתעפויות יוצאת מהכלל עבור פיתוח לא-לינארי.

## יסודות Git ##

אז מה זה Git על רגל אחת? זאת פסקה שחשוב להפנים, מכיוון שאם הבנת מהו Git ואת היסודות לאיך שהוא עובד, אז כנראה יהיה לך הרבה יותר קל להשתמש ב Git ביעילות. תוך כדי שאת לומדת את Git, השתדלי לנקות את הראש משאר הדברים שאולי את יודעת על מנהלי גרסאות אחרים כמו Subversion או Perforce; זה יעזור לך להימנע מלהתבלבל בדקויות של שימוש בכלי. האופן בו Git שומר וחושב על מידע שונה באופן מהותי מהכלים האחרים, למרות שממשק המשתמש די דומה; הבנת ההבדלים תעזור לך שלא להתבלבל בזמן השימוש בו.

### תמונות מצב, לא הבדלים ###

ההבדל המרכזי בין Git ובין מערכות אחרות (כולל Subversion וחבריו) הוא הדרך בה Git חושב על מידע. כתפיסה, רוב המערכות האחרות אוצרות מידע במעין רשימה של שינויים עבור קובץ מסויים. מערכות אלו (CVS, Subversion, Perforce, Bazaar וכך הלאה) חושבות על המידע שהן שומרות כצירוף של קבוצת קבצים והשינויים שנעשו בקבצים אלו לאורך זמן, כפי שמודגם בתרשים 1-4.

Insert 18333fig0104.png 
תרשים 1-4. מערכות אחרות נוטות לאגור מידע כשינויים לגרסת בסיס של כל קובץ.

Git לא חושב על או שומר מידע בדרך זו. לחלופין, Git חושב על המידע שלו כקבוצה של תמונות מצב (snapshots) המתארות מערכת קבצים מיניאטורית. באופן בסיסי, כל פעם שאת מכניסה (commit), או שומרת את המצב של הפרוייקט שלך ב Git, הוא מצלם תמונת מצב של איך שהקבצים שלך נראים באותו רגע ושומר הפניה אל תמונת המצב. לשם היעילות, אם קבצים לא השתנו, Git לא שומר את הקובץ שוב - רק קישור (link) לקובץ הזהה שכבר נשמר קודם. Git חושב על המידע שלו בדומה לתרשים 1-5.

Insert 18333fig0105.png 
תרשים 1-5. Git שומר מידע כתמונות מצב של הפרוייקט לאורך זמן.

זוהי הבחנה חשובה בין Git וכמעט כל שאר מנהלי הגרסאות. זה מכריח את Git לשקול מחדש כמעט כל היבט של ניהול גרסאות, שרוב המערכות האחרות העתיקו מקודמיהן. כך Git נעשה יותר דומה למערכת קבצים קטנה עם כמה כלים חזקים להפליא שבנויים לתוכה, ורחוק מסתם כלי לניהול גרסאות. נחקור כמה מהיתרונות הגלומים בתפיסה זו של מידע כשנלמד על הסתעפות ענפים ב Git בפרק 3.

### כמעט כל פעולה היא מקומית ###

רוב הפעולות ב Git צריכות רק קבצים ומשאבים מקומיים בכדי להתבצע - באופן כללי, אין כלל צורך במידע ממחשב אחר ברשת שלך. אם את רגילה למערכות ריכוזיות, שברוב הפעולות בהן, תשלמי את המחיר ההוא של גישה לרשת, הרי שהצד הזה של Git יגרום לך לחשוב שאלוהי המהירות ברכו את Git בכוחות על טבעיים. מכיוון שכל ההיסטוריה של הפרוייקט נמצא ממש כאן על הדיסק המקומי שלך, רוב הפעולות יראו לך כמעט מיידיות.

לדוגמא, Git לא צריך לגשת לשרת ולהביא את היסטוריית הפרוייקט, כשתרצי לעיין בה - הוא פשוט קורא אותה ישירות מבסיס הנתונים המקומי שלך. זה אומר שאת רואה את הסטוריית הפרוייקט באופן כמעט מיידי. אם תרצי לראות את השינויים שהוצגו (introduced) בין הגרסא הנוכחית של קובץ ובין אותו הקובץ לפני חודש, Git יכול למצוא את הקובץ הישן ולבצע חישוב מקומי של ההבדלים, במקום לבקש משרת מרוחק לעשות זאת או להביא מרחוק את הקובץ הישן ולבצע את החישוב אצלך.

זה גם אומר שיש מעט שלא תוכלי לעשות אם את לא מקוונת או לא ברשת פרטית (VPN). אם את עולה על מטוס או רכבת ורוצה להספיק קצת לעבוד, את יכולה להכניס ללא הפרעה עד שיהיה לך חיבור זמין. אם הגעת הביתה ותוכנת הרשת הפרטית שלך לא משתפת פעולה, תוכלי עדיין לעבוד. במערכות רבות אחרות דבר כזה הוא תהליך כואב או אינו אפשרי כלל. ב Perforce, למשל, לא תוכלי לעשות הרבה אם אינך מחוברת לשרת; וב Subversion או VCS תוכלי לבצע שינויים, אך לא להכניס אותם לבסיס הנתונים, פשוט כי הוא אינו מקוון. זה אולי לא נשמע כזה ביג דיל, אבל תתפלאי איזה הבדל זה יכול לעשות.

### יש ב Git מן השלמות ###

הכל ב Git נסכם לבדיקה (check-summed) לפני שהוא נשמר, ומשם הלאה הסכום משמש כהפניה אליו. המשמעות היא שלא ניתן לשנות את התוכן של כל קובץ או תיקייה בלי ש Git ידע על כך. הפומקציונליות הזו בנויה לתוך Git מן הבסיס והוא חלק אינטגרלי בפילוסופיה של הכלי. אינך יכולה לאבד מידע תוך כדי תנועה או שקובץ יפגם בלי ש Git יוכל לזהות זאת.

המנגנון ש Git משתמש בו לבדיקת הסכום הזה נקרא קידוד SHA-1 (או SHA-1 hash). זוהי מחרוזת בת 40 תווים, הבנויה מספרות הקסדצימליות (0-9 או a-f) ומחושבת על פי התוכן של הקובץ או מבנה התיקייה ב Git. קוד SHA-1 נראה כמו משהו כזה

	24b9da6552252987aa493b52f8696cd6d3b00373

את תראי את הקודים האלו בכל מקום ב Git בגלל שהוא משתמש בהם המון. לאמיתו של דבר, Git שומר כל דבר בבסיס הנתונים ממוען לפי הקוד של התוכן שלו ולא לפי שם הקובץ שלו.

### ככלל, Git רק מוסיף מידע ###

כשאת מבצעת פעולות ב Git, כמעט כולן רק מוסיפות מידע לבסיס הנתונים של Git. קשה מאוד לגרום למערכת לעשות משהו שאינו ניתן לביטול או שמוחק מידע בדרך כלשהי. כמו בכל ניהול גרסאות, את יכולה לאבד או להרוס שינויים שלא הכנסת עדיין; אבל אחרי שהכנסת תמונת מצב לתוך Git, קשה מאוד לאבד אותה, במיוחד אם את דוחפת את הבסיס הנתונים שלך למאגר אחר בצורה סדירה.

זה מה שהופך את השימוש ב Git לתענוג, מכיוון שאנחנו יודעים שנוכל להתנסות בלי הפחד שנשבש את העניינים בצורה קשה. לבחינה עמוקה יותר של איך Git שומר את המידע שלו ואיך תוכלי לשחזר מידע שנראה אבוד, גשי לפרק 9.

### שלושת המצבים ###

עכשיו, שימי לב. זהו הדבר העיקרי על Git שעלייך לזכור אם את רוצה ששאר תהליך הלמידה שלך ילך חלק. ל Git יש שלושה מצבים בהם קובץ יוכל להיות: בפנים (לאחר שהוכנס, committed), שונה (modified), ובתצוגה (staged). בפנים אומר שהמידע שמור בבטחה בבסיס הנתונים המקומי שלך. שונה משמעו ששינית את הקובץ אבל לא הכנסת אותו לבסיס הנתונים עדיין. בתצוגה אומר שסימנת קובץ ששונה בגרסתו הנוכחית והוא יכנס עם תמונת המצב הבאה.

מכאן קצרה הדרך לחלוקת כל פרוייקט Git לשלושה חלקים עיקריים: תיקיית Git, תיקיית העבודה ואזור התצוגה.

Insert 18333fig0106.png 
תרשים 1-6. תיקיית העבודה, אזור התצוגה ותיקיית Git.

תיקיית ה Git הוא המקום בו Git שומר את מידע-העל (metadata) ואת בסיס הנתונים של האובייקטים עבור הפרוייקט שלך. זהו החלק החשוב ביותר ב Git, וזהו החלק שמועתק כשאת משכפלת (clone) מאגר ממחשב אחר.

תיקיית העבודה הוא הוצאה בודדת של גרסא אחת של הפרוייקט. הקבצים האלו נשלפים ממסד הנתונים הדחוס שבתיקיית ה Git ונשמרים לשימושך על הדיסק.

אזור התצוגה הוא קובץ פשוט, שנמצא בדרך כלל בתוך תיקיית ה Git שלך, ששומר מידע על מה נכלל בהכנסה הבאה שלך. לפעמים מכנים אותו  'האינדקס', אבל הכינוי 'אזור התצוגה' הופך בהדרגה להיות הסטנדרט.

תהליך עבודה בסיסי ב Git מתנהל בערך כך:

1. 	את משנה קבצים בתיקיית העבודה שלך.
2.	את מציגה את הקבצים, על ידי הוספה של תמונות המצב שלהם לאזור התצוגה.
3.	את מבצעת הכנסה, פעולה שלוקחת את הקבצים כפי שהם באזור התצוגה ושומרת אותם לצמיתות בתיקיית ה Git.

אם גרסת קובץ מסויימת נמצאת בתיקיית ה Git, היא נחשבת בפנים. אם היא שונתה אבל נוספה לאזור התצוגה, היא בתצוגה. ואם היא שונתה מאז שהוצאה אבל לא הוצגה, אזי היא שונה. בפרק 2, תלמדי עוד על המצבים האלו ואיך לנצל אותם לטובתך או לדלג לגמרי על שלב התצוגה.

## התקנת Git ##

בואי נשתמש בקצת Git. ראשון ראשון ואחרון אחרון - עליך להתקין אותו. תוכלי לשים עליו יד בכמה דרכים; השתיים העיקריות הן להתקין ישירות מהקוד או להתקין חבילה קיימת המתאימה לפלטפורמה שלך.

### התקנה מהקוד ###

אם את יכולה, בדרך כלל עדיף להתקין Git מהקוד, מכיוון שכך תקבלי את הגרסא המעודכנת ביותר. כל גרסא של Git נוטה לכלול שיפורי ממשק משתמש מועילים, כך שלקחת את הגרסא האחרונה היא לרוב הצעד הטוב ביותר אם את מרגישה בנוח לבנות תוכנה (compile) מקוד המקור. כמו כן, לרוב, יש להפצות לינוקס ספריות תוכנה מאוד ישנות; לכן, אלא אם אתה רץ על הפצה מאוד מעודכנת, התקנה מהקוד יכולה להיות ההימור הטוב ביותר.

כדי להתקין Git, צריכות להיות לך הספריות הבאות ש Git תלוי בהן: curl, zlib, openssl, expat, וכן libiconv. לדוגמא, אם את על מערכת שיש לה yum (כמו Fedora) או apt-get (כגון מערכות מבוססות Debian), תוכלי להשתמש באחת מהפקודות הבאות כדי להתקין את כל התלויות:

	yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel $

	apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev $

כשיהיו לך את כל התלויות ההכרחיות, תוכלי להתקדם ולהשיג את תמונת המצב באחרונה מהאתר של Git:

	http://git-scm.com/download
	
ואז, בני והתקיני:

	tar -zxf git-1.7.2.2.tar.gz $
	cd git-1.7.2.2 $
	make prefix=/usr/local all $
	sudo make prefix=/usr/local install $

לסיום, תוכלי לקבל Git מעודכן דרך Git עצמו:

	git clone git://git.kernel.org/pub/scm/git/git.git $
	
### התקנה על לינוקס ###

אם תרצי להתקין Git על לינוקס באמצעות מתקין בינרי, תוכלי בעיקרון לעשות זאת דרך מנהל הספריות הבסיסי שמגיע עם ההפצה שלך. אם את על Fedora, תוכלי להשתמש ב yum:

	yum install git-core $

או אם את בהפצה מבוססת Debian, כמו Ubuntu, נסי את apt-get:

	apt-get install git-core $

### התקנה על מק ###

יש שתי דרכים קלות להתקין Git על מק. הקלה ביותר היא להשתמש במתקין הגרפי' אותו תוכלי להוריד מעמוד Google Code (ראי תרשים 1-7):

	http://code.google.com/p/git-osx-installer

Insert 18333fig0107.png 
תרשים 1-7. מתקין Git עבור מערכת הפעלה OS X.

הדרך השניה היא להתקין Git דרך MacPorts (`http://www.macports.org`). אם מותקן אצלך MacPorts, התקיני את Git באמצעות

	sudo port install git-core +svn +doc +bash_completion +gitweb $

את לא צריכה להתקין את כל התוספות, אבל את כנראה תרצי לכלול את svn+ במקרה שאי פעם תרצי להשתמש ב Git עם מאגרי Subversion (ראי פרק 8).

### התקנה על חלונות ###

התקנת Git על חלונות היא קלה ביותר. לפרוייקט msysGit יש את אחד מתהליכי ההתקנה הקלים ביותר שתראי. פשוט הורידי את קובץ ההתקנה המסתיים ב exe מעמוד Google Code, והריצי אותו: 

	http://code.google.com/p/msysgit

אחרי ההתקנה, יהיו לך גרסת שורת-פקודה (הכוללת לקוח SSH שיבוא לידי שימוש עוד מעט) וגרסת ממשק המשתמש הסטנדרטית.

## הגדרת Git בפעם הראשונה ##

עכשיו שיש לך Git במערכת, תרצי להגדיר כמה דברים בכדי להתאים את סביבת Git לצרכיך. עליך לעשות זאת באופן חד פעמי; ההגדרות ישארו בסביבה, גם בין עדכונים. תוכלי גם כן לשנות אותן בכל זמן על ידי ביצוע הפקודות שוב. 

Git מגיע עם כלי שנקרא git config שמאפשר לך לכתוב ולקרוא הגדרות ששולטות בכל היבט שקשור באיך ש Git נראה ומתנהג. הגדרות אלו יכולות להתאחסן בשלושה מקומות שונים:

*	קובץ `/etc/gitconfig`: מכיל ערכים עבור כל משתמש במערכת וכל המאגרים שלו. אם תעבירי את האופציה ` --system` ל `git config`, הוא יקרא ויכתוב מהקובץ המסויים הזה.
*	קובץ `~/.gitconfig`: יחודי למשתמש שלך. את יכולה לגרום ל Git לקרוא ולכתוב לקובץ המסויים הזה על ידי שימוש באופציה `--global`.
*	קובץ הגדרות בתיקיית Git (שהוא `.git/config`) או איזה מאגר שאת משתמשת כעת: יחודי למאגר המסויים הזה. כל רמת הגדרה דורסת ערכים ברמה קודמת, כך שערכים ב `.git/config` יעלו על אלו שנמצאים ב `/etc/gitconfig`.

בחלונות, Git יחפש את קובץ `.gitconfig` בתיקיית `$HOME` (היא `C:\Documents and Settings\$USER` עבור רוב האנשים). הוא עדיין יחפש את /etc/gitconfig, למרות שהוא ימוקם באופן יחסי להתקנת Msys, שהיא איפה שתחליטי להתקין את Git על מחשב שלך בזמן הרצת ההתקנה.

### הזהות שלך ###

הדבר הראשון שעלייך לעשות כשאת מתקינה Git הוא לקבוע את שם המשתמש שלך ואת כתובת הדוא"ל שלך. זה חשוב מכיוון שכל הכנסה ב Git משתמשת בנתונים האלו, והם צרובים לתוך כל הכנסה שאת מעבירה מפה לשם:

	$ git config --global user.name "John Doe"
	$ git config --global user.email johndoe@example.com

שוב, עליך לעשות זאת רק פעם אחת אם את מעבירה את אופציית `--global`, מכיוון ש Git תמיד ישתמש בנתונים האלו לכל דבר שתעשי במערכת הזו. אם תרצי לדרוס אותם עם שם או כתובת שונה לפרוייקט מסויים, תוכלי להריץ את הפקודה ללא `--global` כשאת בתיקיית אותו פרוייקט.

### העורך שלך ###

עכשיו שהזהות שלך מסודרת, את יכולה לקבוע את עורך הטקסט בו תשתמשי כש Git ירצה שתקלידי איזשהו מסר. ברירת המחדל היא עורך הטקסט הקבוע במערכת שלך, שהוא בדרך כלל Vi או Vim. אם תרצי להשתמש בעורך אחר, כדוגמת Emacs, תוכלי לעשות כך:

	$ git config --global core.editor emacs
	
### כלי ההשוואה שלך ###

עוד אופציה מועילה שאולי ברצונך לקבוע היא כלי ההשוואה שאיתו פותרים התנגשויות מיזוג. נניח שתבחרי ב vimdiff:

	$ git config --global merge.tool vimdiff

Git מקבל  kdiff3, tkdiff, meld, xxdiff, emerge, vimdiff, gvimdiff, ecmerge, וכן opendiff ככלי מיזוג תקינים. תוכלי גם לקבוע כלי אחר; ראי פרק 7 לעוד מידע על הדרך לעשות זאת.

### בדיקת ההגדרות שלך ###

אם תרצי לבדוק את ההגדרות שלך, תוכלי להשתמש בפקודת `git config --list` בכדי לפרט את כל ההגדרות ש Git יכול למצוא כרגע:

	$ git config --list
	user.name=Scott Chacon
	user.email=schacon@gmail.com
	color.status=auto
	color.branch=auto
	color.interactive=auto
	color.diff=auto
	...

אולי תראי כמה מפתחות שחוזרים על עצמם, מכיוון ש Git קורא את אותו מפתח מקבצים שונים (`/etc/gitconfig`  וגם `~/.gitconfig` לדוגמא). במקרים כאלו, Git ישתמש בערך האחרון לכל מפתח יחודי שיראה.

בנוסף תוכלי לבדוק מהו הערך ש Git מחשב עבור מפתח מסוים על ידי הקשת הפקודה `git config {מפתח}`:

	$ git config user.name
	Scott Chacon

## קבלת עזרה ##

אם אי פעם תזדקקי לעזרה כשתשתמשי ב Git, יש שלוש דרכים למצוא עזרה במדריך ההפעלה (manpage) לכל פקודת Git:

	$ git help <פועל>
	$ git <פועל> --help
	$ man git-<פועל>

לדוגמא, תוכלי לקבל את העמוד במדריך עבור פקודת config אם תריצי 

	$ git help config

אלו פקודות נחמדות מכיוון שאפשר לגשת אליהם מכל מקום, אפילו כשאת לא מקוונת.
אם המדריך והספר הזה אינם מספיקים ואת צריכה עזרה אישית, נסי את ערוצי #git או  #github בשרת Freenode IRC (irc.freenode.net). ערוצים אלו מלאים באופן קבוע באנשים בעלי ידע רב על Git ובדרך כלל ששים לעזור.

## סיכום ##

עכשיו צריכה להיות לך הבנה בסיסית של מהו Git וכיצד הוא שונה ממנהלי גרסאות ריכוזיים בהם את אולי משתמשת עכשיו. צריכה להיות לך גם סביבה עובדת של Git במערכת שלך, בה מוגדרים הפרטים האישיים שלך. זה הזמן ללמוד כמה יסודות של Git.
